const express = require('express');
const router = express.Router();
const Listing = require('../models/Listing');
const upload = require('./multerConfig');
const path = require('path');
const fs = require('fs');
const axios = require('axios');
const FormData = require('form-data');
const { ImageAnnotatorClient } = require('@google-cloud/vision').v1;

// Initialize the client
const client = new ImageAnnotatorClient();
const aiHints = [
  'ai-generated', '3d render', 'digital art', 'generated by', 'midjourney',
  'dall-e', 'stablediffusion', 'artstation', 'stock image', 'render'
];

// Allowed property-related labels
const allowedLabels = [
  'house', 'room', 'bedroom', 'kitchen', 'bathroom',
  'living room', 'apartment', 'flat', 'home', 'interior', 'architecture',
  'gym', 'washroom', 'condominium', 'Gated community', 'balcony',
  'flooring', 'swimming pool', 'furniture'
];

async function isAIGenerated(filePath) {
  try {
    const [result] = await client.annotateImage({
      image: { source: { filename: filePath } },
      features: [
        { type: 'LABEL_DETECTION' },
        { type: 'TEXT_DETECTION' },
        { type: 'IMAGE_PROPERTIES' }
      ]
    });

    const labels = result.labelAnnotations?.map(label => label.description.toLowerCase()) || [];
    const texts = result.textAnnotations?.map(t => t.description.toLowerCase()) || [];

    // Check if any AI hint exists in labels or text
    const hasAIHint = [...labels, ...texts].some(tag =>
      aiHints.some(hint => tag.includes(hint))
    );

    if (hasAIHint) {
      console.log('⚠️ AI-generated image detected via hints');
      return true;
    }

    // Optional: Analyze dominant colors
    const props = result.imagePropertiesAnnotation;
    if (props && props.dominantColors) {
      const colors = props.dominantColors.colors;
      const flatColors = colors.every(c => c.pixelFraction < 0.6); // Synthetic images often use flat colors
      const highSaturation = colors.some(c => c.color.saturation > 0.95);

      if (flatColors && highSaturation) {
        console.log('🎨 Image may be AI-generated due to flat/high-saturation colors');
        return true;
      }
    }

    console.log('✅ Image seems to be original');
    return false;

  } catch (error) {
    console.error('Google Vision error:', error.message);
    return false;
  }
}

async function isPropertyImage(filePath) {
  try {
    const [result] = await client.labelDetection(filePath);
    const labels = result.labelAnnotations?.map(label => label.description.toLowerCase()) || [];
    
    const isValid = labels.some(label =>
      allowedLabels.some(allowed => label.includes(allowed))
    );

    console.log('🧠 Google Vision result:', labels);
    return isValid;

  } catch (error) {
    console.error('Google Vision error:', error.message);
    return false;
  }
}

/*──────────────────────────  CREATE  ──────────────────────────*/
router.post('/create', upload.fields([
  { name: 'images', maxCount: 10 },
  { name: 'videos', maxCount: 5 }
]), async (req, res) => {
  try {
    const body = req.body;

    let parsedAmenities = {};
    if (typeof body.amenities === 'string') {
      try {
        parsedAmenities = JSON.parse(body.amenities);
      } catch (e) {
        parsedAmenities = {};
      }
    }

    const updateData = {
      userKey: body.userKey,
      userType: body.userType,
      userinterests: body.userinterests,
      gender: body.gender,
      languages: body.languages,
      foodchoices: body.foodchoices,
      pets: body.pets,
      propertyAddress: body.propertyAddress,
      locality: body.locality,
      propertyStructure: body.propertyStructure,
      roomType: body.roomType,
      washroomType: body.washroomType,
      parkingType: body.parkingType,
      roomSize: body.roomSize,
      apartmentSize: body.apartmentSize,
      rent: body.rent,
      securityDepositOption: body.securityDepositOption,
      amenities: parsedAmenities,
      cookingType: body.cookingType,
      mapLocation: body.mapLocation,
      city: body.city,
      state: body.state,
      country: body.country,
      pinCode: body.pinCode,
      accommodationType: body.accommodationType,
      title: body.title,
      description: body.description,
      validPics: [], // Initialize as array
      AIGenpics: []  // Initialize as array
    };

    // Handle date fields safely
    if (body.availableFrom && body.availableFrom !== 'Invalid date' && body.availableFrom !== 'null') {
      updateData.availableFrom = new Date(body.availableFrom);
    } else {
      updateData.availableFrom = undefined;
    }

    if (body.openDate && body.openDate !== 'Invalid date' && body.openDate !== 'null') {
      updateData.openDate = new Date(body.openDate);
    } else {
      updateData.openDate = undefined;
    }

    const tempDir = path.join(__dirname, '..', 'uploads');
    const validImages = [];
    const rejectedImages = [];

    if (req.files?.images) {
      for (const file of req.files.images) {
        if (!file || !file.buffer) {
          console.warn('🚫 Invalid file or missing buffer:', file.originalname || 'unknown');
          continue;
        }
        
        const ext = path.extname(file.originalname).toLowerCase();
        const tempPath = path.join(tempDir, `temp-${Date.now()}-${file.originalname}`);

        try {
          fs.writeFileSync(tempPath, file.buffer);
        } catch (writeErr) {
          console.error(`🚨 Failed to write temp file: ${file.originalname}`, writeErr.message);
          continue;
        }

        const isValid = await isPropertyImage(tempPath);
        const isAIgen = await isAIGenerated(tempPath);
        
        const finalFilename = `media-${Date.now()}-${Math.round(Math.random() * 1E9)}${ext}`;
        const finalPath = path.join(tempDir, finalFilename);

        try {
          fs.renameSync(tempPath, finalPath);
          validImages.push(`/uploads/${finalFilename}`);
          console.log("Image is validity is "+isValid);
          updateData.validPics.push(isValid);
          updateData.AIGenpics.push(isAIgen);
        } catch (renameErr) {
          console.error(`🚨 Failed to rename file: ${file.originalname}`, renameErr.message);
          fs.unlinkSync(tempPath);
        }
      }
    }

    updateData.images = validImages.length > 0 ? validImages : undefined;

    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined || updateData[key] === '') {
        delete updateData[key];
      }
    });

    const newListing = new Listing(updateData);
    await newListing.save();

    res.status(201).json({ 
      message: 'Listing created successfully',
      rejectedImages: rejectedImages.length > 0
        ? `${rejectedImages.length} image(s) were not saved - only house/property-related images are allowed`
        : undefined,
      listing: newListing
    });

  } catch (error) {
    console.error('Error creating listing:', error);
    res.status(500).json({ message: 'Server error while creating listing', error: error.message });
  }
});

/*──────────────────────────  READ ALL  ────────────────────────*/
router.get('/', async (req, res) => {
  try {
    const listings = await Listing.find();
    res.json(listings);
  } catch (error) {
    console.error('Failed to fetch listings:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

/*──────────────────────────  READ BY USER  ────────────────────*/
router.get('/user/:userKey', async (req, res) => {
  try {
    const decoded = decodeURIComponent(req.params.userKey);
    const listings = await Listing.find({ userKey: decoded });
    res.status(200).json(listings);
  } catch (err) {
    console.error('Error fetching listings for user:', err);
    res.status(500).json({ message: 'Server error' });
  }
});

/*──────────────────────────  STATS ENDPOINT  ──────────────────*/
router.get('/stats/:userKey', async (req, res) => {
  try {
    const listings = await Listing.find({ userKey: req.params.userKey });

    const stats = listings.map(l => ({
      _id: l._id,
      propertyAddress: l.propertyAddress,
      locality: l.locality,
      propertyStructure: l.propertyStructure,
      viewsLog: l.viewsLog || []
    }));

    res.json(stats);
  } catch (err) {
    console.error('Error building stats:', err);
    res.status(500).json({ message: 'Server error' });
  }
});

/*──────────────────────────  READ ONE & INCREMENT VIEWS  ─────*/
router.get('/:id', async (req, res) => {
  const viewer = req.query.viewer || null;

  const update = {
    $inc: { viewsCount: 1 },
    $push: {
      viewsLog: {
        date: new Date(),
        viewer
      }
    }
  };

  try {
    const updated = await Listing.findByIdAndUpdate(req.params.id, update, { new: true });
    if (!updated) return res.status(404).json({ message: 'Listing not found' });
    res.status(200).json(updated);
  } catch (err) {
    console.error('Error fetching/updating listing:', err);
    res.status(500).json({ message: 'Server error' });
  }
});

/*──────────────────────────  UPDATE  ──────────────────────────*/
/*──────────────────────────  UPDATE  ──────────────────────────*/
router.put('/:listingId', upload.fields([
  { name: 'images', maxCount: 10 },
  { name: 'videos', maxCount: 5 }
]), async (req, res) => {
  try {
    const body = req.body;

    let parsedAmenities = {};
    if (typeof body.amenities === 'string') {
      try {
        parsedAmenities = JSON.parse(body.amenities);
      } catch (e) {
        parsedAmenities = {};
      }
    }

    const updateData = {
      userKey: body.userKey,
      userType: body.userType,
      userinterests: body.userinterests,
      gender: body.gender,
      languages: body.languages,
      foodchoices: body.foodchoices,
      pets: body.pets,
      propertyAddress: body.propertyAddress,
      locality: body.locality,
      propertyStructure: body.propertyStructure,
      roomType: body.roomType,
      washroomType: body.washroomType,
      parkingType: body.parkingType,
      roomSize: body.roomSize,
      apartmentSize: body.apartmentSize,
      rent: body.rent,
      securityDepositOption: body.securityDepositOption,
      amenities: parsedAmenities,
      cookingType: body.cookingType,
      mapLocation: body.mapLocation,
      city: body.city,
      state: body.state,
      country: body.country,
      pinCode: body.pinCode,
      accommodationType: body.accommodationType,
      title: body.title,
      description: body.description,
      validPics: [],
      AIGenpics: []
    };

    // Sanitize date fields
    if (body.availableFrom && body.availableFrom !== 'Invalid date' && body.availableFrom !== 'null') {
      updateData.availableFrom = new Date(body.availableFrom);
    } else {
      updateData.availableFrom = undefined;
    }

    if (body.openDate && body.openDate !== 'Invalid date' && body.openDate !== 'null') {
      updateData.openDate = new Date(body.openDate);
    } else {
      updateData.openDate = undefined;
    }

    // Get current listing data first
    const currentListing = await Listing.findById(req.params.listingId);
    let existingValidPics = currentListing?.validPics || [];
    let existingAIGenPics = currentListing?.AIGenpics || [];

    // Process updated images list from frontend
    let finalImages = [];
    let updatedValidPics = [];
    let updatedAIGenpics = [];

    if (body.updatedImages) {
      try {
        finalImages = JSON.parse(body.updatedImages);
        
        // Rebuild validation arrays by matching with original images
        finalImages.forEach(imgPath => {
          const originalIndex = currentListing?.images?.indexOf(imgPath);
          if (originalIndex >= 0 && originalIndex < existingValidPics.length) {
            updatedValidPics.push(existingValidPics[originalIndex]);
            updatedAIGenpics.push(existingAIGenPics[originalIndex]);
          }
        });
      } catch (e) {
        console.error('Invalid updatedImages:', e);
      }
    }

    // Process new uploads
    const tempDir = path.join(__dirname, '..', 'uploads');

    if (req.files?.images) {
      for (const file of req.files.images) {
        if (!file || !file.buffer) {
          console.warn('🚫 Invalid file or missing buffer:', file.originalname || 'unknown');
          continue;
        }

        const ext = path.extname(file.originalname).toLowerCase();
        const tempPath = path.join(tempDir, `temp-${file.originalname}`);

        try {
          fs.writeFileSync(tempPath, file.buffer);
        } catch (writeErr) {
          console.error(`🚨 Failed to write temp file: ${file.originalname}`, writeErr.message);
          continue;
        }

        const isValid = await isPropertyImage(tempPath);
        const isAIgen = await isAIGenerated(tempPath);
        
        const finalFilename = `media-${Date.now()}-${Math.round(Math.random() * 1E9)}${ext}`;
        const finalPath = path.join(tempDir, finalFilename);

        fs.renameSync(tempPath, finalPath);
        finalImages.push(`/uploads/${finalFilename}`);
        updatedValidPics.push(isValid);
        updatedAIGenpics.push(isAIgen);
      }
    }

    // Update the data with synchronized arrays
    updateData.images = finalImages.length > 0 ? finalImages : undefined;
    updateData.validPics = updatedValidPics;
    updateData.AIGenpics = updatedAIGenpics;

    // Process videos (unchanged)
    let finalVideos = [];
    if (body.updatedVideos) {
      try {
        finalVideos = JSON.parse(body.updatedVideos);
      } catch (e) {
        console.error('Invalid updatedVideos:', e);
      }
    }
    updateData.videos = finalVideos.filter(vid => typeof vid === 'string');

    // Remove empty values
    Object.keys(updateData).forEach(key => {
      if (updateData[key] === undefined || updateData[key] === '') {
        delete updateData[key];
      }
    });

    // Delete old files that were removed
    if (currentListing) {
      const oldImagePaths = currentListing.images || [];
      const deletedImages = oldImagePaths.filter(img => !updateData.images?.includes(img));

      const oldVideoPaths = currentListing.videos || [];
      const deletedVideos = oldVideoPaths.filter(vid => !updateData.videos?.includes(vid));

      [...deletedImages, ...deletedVideos].forEach(filePath => {
        const fullPath = path.join(__dirname, '..', filePath);
        fs.access(fullPath, fs.constants.F_OK, (err) => {
          if (err) {
            console.warn(`File does not exist: ${filePath}`);
            return;
          }

          fs.unlink(fullPath, (deleteErr) => {
            if (deleteErr) {
              console.error(`🚨 Failed to delete file: ${filePath}`, deleteErr);
            } else {
              console.log(`✅ Deleted file: ${filePath}`);
            }
          });
        });
      });
    }

    // Save updated listing
    const updatedListing = await Listing.findByIdAndUpdate(
      req.params.listingId,
      { $set: updateData },
      { new: true, runValidators: true }
    );

    if (!updatedListing) {
      return res.status(404).json({ message: 'Listing not found' });
    }

    res.json(updatedListing);

  } catch (err) {
    console.error('Failed to update listing:', err);
    res.status(500).json({ message: 'Failed to update listing', error: err.message });
  }
});

/*──────────────────────────  DELETE  ──────────────────────────*/
router.delete('/:id', async (req, res) => {
  try {
    const result = await Listing.findByIdAndDelete(req.params.id);
    if (!result) {
      return res.status(404).json({ message: 'Listing not found' });
    }

    res.status(200).json({ message: 'Listing deleted' });
  } catch (err) {
    console.error('Error deleting listing:', err);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;